

"not used , trying to init session.vim if existed
function! s:init()
	let result=split(system("dir"))
	for fileName in result
		if fileName=="session.vim"
			source session.vim
			return
		endif
	endfor
endfunction

" save opened state with session.vim...
" command! -n=0 -bar WQ call s:saveCloseProject()
command WQ wqa
command Q qa
autocmd VimLeavePre * call s:recordCloseProject()
function! s:saveCloseProject()
	call s:recordCloseProject()
	wqa
endfunction
function! s:recordCloseProject()
	let pageChange=":tabn ".string(tabpagenr())
	let sessionFileName=expand("~")."/.vimtmp/session.vim"
	let allFileNames=s:GetAllBufferName()
	let outLine=[]
	if len(allFileNames)>=1
		call add(outLine,":edit ".allFileNames[0])
	endif
	for name in allFileNames[1:]
		call add(outLine,":tabe ".name)
	endfor
	call add(outLine,pageChange)
	call writefile(outLine,sessionFileName)
endfunction

function! s:GetAllBufferName()
	let reList=[]
	for pageNum in range(1,tabpagenr("$"))
		for bufNum in tabpagebuflist(pageNum)
			if match(bufname(bufNum),"NERD_tree_")<0
				let bufFileName = expand("#".bufNum.":p")
				if filereadable(bufFileName)
					call add(reList,bufFileName)
				endif
			endif
		endfor
	endfor
	return reList
endfunction

" make tag and open tag file below
command! -n=0 -bar TAG call s:VsctagsRight()
function! s:VsctagsRight()
	call system("ctags -f ~/.vimtmp/tags --sort=no ".expand('%:p'))
	botright 10 split ~/.vimtmp/tags
	nnoremap <buffer><silent>o <C-]><C-w>w:q<CR>
	nnoremap <buffer><silent>t <C-w><C-]><C-w>T
	setlocal nomodifiable
endfunction

" git diff in local
command! -n=0 -bar DIFF call s:Vsgitdiff()
function! s:Vsgitdiff()
	let curPath = getcwd()
	let filePath = expand("%:p:h")
	exec "cd ".filePath
	call system("git diff ".expand("%:p")." > ~/.vimtmp/DIFF_TEMP")
	exec "cd ".curPath
	tabe ~/.vimtmp/DIFF_TEMP
endfunction


"
function! s:GetMRUFile()
    " If the MRU file is present, then load the list of filenames. Otherwise
    " start with an empty list.
    if filereadable(g:MRU_File)
        let MRU_files = readfile(g:MRU_File)
        if l:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
            " Generated by the previous version of the MRU plugin.
            " Discard the list.
            let MRU_files = []
        elseif l:MRU_files[0] =~# '^#'
            " Remove the comment line
            call remove(l:MRU_files, 0)
        else
            " Unsupported format
            let MRU_files = []
        endif
    else
        let MRU_files = []
    endif
	let existFiles = []
	for mruName in l:MRU_files
		if filereadable(mruName)
			call add(existFiles, mruName)
		endif
	endfor
	return l:existFiles
endfunction

"
function! OpenFileByLine()
	let line=getline('.')
	if filereadable(l:line)
		exec "tabe ".l:line
	else
		echo "file not found"
	end
endfunction

" find file and open list below
function! s:searchFile(fileName, directory)
	if a:directory==""
		call system("find . |grep ".a:fileName." > ~/.vimtmp/search_list")
	else
		call system("find ".a:directory." |grep ".a:fileName." > ~/.vimtmp/search_list")
	endif
	botright 10 split ~/.vimtmp/search_list
	nnoremap <buffer><silent>t :call OpenFileByLine()<CR>
	setlocal nomodifiable
endfunction
function! s:searchFileInGit(fileName)
	let beforePath = getcwd()
	while 1
		let curPath = getcwd()
		if isdirectory(l:curPath."/.git")
			s:searchFile(fileName, curPath)
			break
		elseif l:curPath=="/"
			break
		else
			cd ..
		endif
	endwhile
	exec "cd ".beforePath
endfunction
command! -nargs=1 -bar SearchInGit call s:searchFileInGit(<q-args>)

" -----------------------------------------------------------------{{{ [[[
" open lastest openfile
function! OpenLastClose()
	let openFiles=s:GetAllBufferName()
	let closeFiles=s:GetMRUFile()
	for closeName in l:closeFiles
		let isClose = 1
		for openName in l:openFiles
			if l:openName == l:closeName
				let isClose = 0
				break
			endif
		endfor
		if l:isClose == 1
			exec "tabe ".closeName
			break
		endif
	endfor
endfunction

" search filename and open in mru list
function! OpenWithSingleFileName(fileName)
	let mruFiles=s:GetMRUFile()
	if a:fileName == ''
		call OpenLastClose()
		return
	endif
	for mruName in l:mruFiles
		let singleFileName = split(mruName, "/")[-1]
		if singleFileName == a:fileName
			for pageNum in range(1,tabpagenr("$"))
				for bufNum in tabpagebuflist(pageNum)
					if match(bufname(bufNum),"NERD_tree_")<0
						let bufFileName = expand("#".bufNum.":p")
						if filereadable(bufFileName)
							if bufFileName == mruName
								exec "tabn ".pageNum
								return
							endif
						endif
					endif
				endfor
			endfor
			exec "tabe ".mruName
			return
		endif
	endfor
	echo a:fileName." File not found.."
endfunction

" @cz MRU_SingleComplete
function! s:MRU_SingleComplete(ArgLead, CmdLine, CursorPos)
	let singleList = []
	let mruFiles = s:GetMRUFile()
	for pathFileName in l:mruFiles
		let singleFileName = split(pathFileName,"/")[-1]
		call add(singleList, singleFileName)
	endfor
    if a:ArgLead == ''
        " Return the complete list of MRU files
        return l:singleList
    else
        " Return only the files matching the specified pattern
        return filter(copy(l:singleList), 'v:val =~? a:ArgLead')
    endif
endfunction


nmap t :Tabe<space>
nmap <s-t> :Tabe<CR>
"nmap s :SearchInGit<space> bad coding ... giveup

command! -nargs=? -complete=customlist,s:MRU_SingleComplete Tabe call OpenWithSingleFileName(<q-args>)
"]]] }}}
"
"
"


" copy from https://stackoverflow.com/questions/35837990/how-to-trigger-omnicomplete-auto-completion-on-keystrokes-in-insert-mode
set completeopt+=menuone " don't insert text automatically
set completeopt-=preview " don't show preview window
"set pumheight=5 " keep the autocomplete suggestion menu small
set shortmess+=c " don't give ins-completion-menu messages

" if completion menu closed, and two non-spaces typed, call autocomplete
function! OpenCompletion()
	if (&filetype == "thlua") || (&filetype == "lua")
		let l:prechar = getline(".")[col(".")-2]
		if !pumvisible() && (l:prechar==':' || l:prechar==".")
			return "\<C-x>\<C-o>"
		endif
	endif
	return "\<C-n>"
endfunction

"autocmd InsertCharPre * silent! call OpenCompletion()
"inoremap <expr><C-n> pumvisible() ? "\<Down>" : "\<C-n>"
"inoremap <expr><C-p> pumvisible() ? "\<Up>" : "\<C-p>"
inoremap <expr><C-n> OpenCompletion()
